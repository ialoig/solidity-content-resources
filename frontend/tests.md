# Getting Set Up

## Build Artifacts

Every time you compile a smart contract, the Solidity compiler generates a JSON file (referred to as build artifacts) which contains the binary representation of that contract and saves it in the `build/contracts` folder.

Next, when you run a migration, Truffle updates this file with the information related to that network.

The first thing you'll need to do every time you start writing a new test suite is to load the build artifacts of the contract you want to interact with. This way, Truffle will know how to format our function calls in a way the contract will understand.

Let's look at a simple example.

Say there was a contract called myAwesomeContract. We could do something like the following to load the build artifacts:

```shell
const myAwesomeContract = artifacts.require(“myAwesomeContract”);
```

The function returns something called a contract `abstraction`. In a nutshell, a contract abstraction hides the complexity of interacting with Ethereum and provides a convenient JavaScript interface to our Solidity smart contract. We'll be using it in the next chapters.

## The contract() function

Behind the scenes, Truffle adds a thin wrapper around **Mocha** in order to make testing simpler. Since our course focuses on Ethereum development, we won't be spending much time explaining the bits and bytes of Mocha. 

If you're inclined to learn more about Mocha, check out their [website](https://mochajs.org/).

What we cover here - how to:

- group tests by calling a function named `contract()`. It extends Mocha's `describe()` by providing a list of accounts for testing and doing some cleanup as well.

`contract()` takes two arguments. The first one, a `string`, must indicate what we’re going to test. The second parameter, a `callback`, is where we’re going to actually write our tests.

- execute them: the way we’ll be doing this is by calling a function named `it()` which also takes two arguments: a `string` that describes what the test actually does and a `callback`.

Putting it together, here's a bare-bones test:
```shell
 contract("MyAwesomeContract", (accounts) => {
   it("should be able to receive Ethers", () => {
   })
 })
```

> Note: A well-thought test explains what the code actually does. Make sure the description of the test suite and the test case can be read together as a coherent statement. It’s like you’re writing documentation.

Usually, every test has the following phases:

- `set up`: in which we define the initial state and initialize the inputs.

- `act`: where we actually test the code. Always make sure you test only one thing.

- `assert`: where we check the results.

Lets look at what our test should do in some more detail.

## 1. Set up
A contract abstraction, as its name says, is just an `abstraction`. In order to actually interact with our smart contract, we have to create a JavaScript object that will act as an instance of the contract. Continuing our example with myAwesomeContract, we can use the contract abstraction to initialize our instance like this:

```shell
const contractInstance = await myAwesomeContract.new();
```

## 2. Act

How can we make it so the method "knows" who calls it? 

Well... the problem is solved with the contract abstraction. One of the features of Truffle is that it wraps the original Solidity implementation and lets us specify the address that makes the function call by passing that address as an argument.

The following calls myFunction and makes sure `msg.sender` is set to Alice's address:

```shell
const result = await contractInstance.myFunction(array[0], {from: alice});
```

Now I have a quick question for you: do you know what gets stored in result?

Well, let me explain.

## Logs and Events
Once we specified the contract we wanted to test using artifacts.require, Truffle automatically provides the logs generated by our smart contract. What this means is that we can now retrieve the name of Alice's newly created zombie using something like this: result.logs[0].args.name. In a similar fashion, we can get the id and the _dna.

Besides these bits of information, result is going to be giving us several other useful details about the transaction:

- `result.tx`: the transaction hash
- `result.receipt`: an object containing the transaction receipt. If `result.receipt.status` is equal to `true` it means that the transaction was successful. Otherwise, it means that the transaction failed.

> Note: Note that logs can also be used as a much cheaper option to store data. The downside is that they can't be accessed from within the smart contract itself.

## 3. Assert
In this chapter we will be using the built-in assertion module which comes with a set of assertion functions such as `equal()` and `deepEqual()`. Simply put, these functions check the condition and throw an error if the result is not as expected.


# Hooks
We'll have more than one test and the way this works is that each test should start with a clean sheet. Thus, for every single test we'll have to create a new instance of our smart contract like so:

```shell
const contractInstance = await CryptoZombies.new();
```
Wouldn't be nice if you could write this just once and have Truffle run it automatically for every test?

Well... one of Mocha's (and Truffle's) features is the ability to have some snippets of code called hooks run before or after a test. To run something before a test gets executed, the code should be put inside a function named `beforeEach()`.

So, instead of writing `contract.new()` several times, you just do it once like this:

```shell
beforeEach(async () => {
  // let's put here the code that creates a new contract instance
});
```
Then, `Truffle` will take care of everything.



Now, let's circle back to how `contract.new` works. Basically, every time we call this function, Truffle makes it so that a new contract gets deployed.

On one side, this is helpful because it lets us start each test with a clean sheet.

On the other side, if everybody would create countless contracts the blockchain will become bloated. We want you to hang around, but not your old test contracts!

We would want to prevent this from happening, right?

Happily, the solution is pretty straightforward... our contract should selfdestruct once it's no longer needed.

The way this works is as follows:

- **first**, we would want to add a new function to the MyContract smart contract like so:

```shell
function kill() public onlyOwner {
   selfdestruct(owner());
}
```

> Note: If you want to learn more about `selfdestruct()`, you can read the Solidity docs [here](https://docs.soliditylang.org/en/v0.8.11/introduction-to-smart-contracts.html?highlight=self%20destruct#deactivate-and-self-destruct). The most important thing to bear in mind is that `selfdestruct` is the only way for code at a certain address to be removed from the blockchain. This makes it a pretty important feature!

- **next**, somewhat similar to the `beforeEach()` function explained above, we'll make a function called `afterEach()`:

```shell
afterEach(async () => {
   await contractInstance.kill();
});
```

- **Lastly**, Truffle will make sure this function is called after a test gets executed.

And voila, the smart contract removed itself!


# Time Travelling
Ganache provides a way to move forward in time through two helper functions:

- `evm_increaseTime`: increases the time for the next block.
- `evm_mine`: mines a new block.
You don't even need a Tardis or a DeLorean for this kind of time travel.

Let me explain how these functions work:

- Every time a new block gets mined, the miner adds a timestamp to it. Let's say the transactions that created our zombies got mined in block 5.

- Next, we call `evm_increaseTime` but, since the blockchain is immutable, there is no way of modifying an existing block. So, when the contract checks the time, it will not be increased.

- If we run `evm_mine`, block number 6 gets mined (and timestamped) which means that, when we put the zombies to fight, the smart contract will "see" that a day has passed.

Putting it together, we can fix our test by traveling through time as follows:

```shell
await web3.currentProvider.sendAsync({
  jsonrpc: "2.0",
  method: "evm_increaseTime",
  params: [86400],  // there are 86400 seconds in a day
  id: new Date().getTime()
}, () => { });

web3.currentProvider.send({
    jsonrpc: '2.0',
    method: 'evm_mine',
    params: [],
    id: new Date().getTime()
});
```

> Note: Obviously, time traveling is not available on the main net or on any of the available test chains that are secured by miners. It would make a real mess of things if anyone could just choose to change how time operates in the real world! For testing smart contracts, time travel can be an essential part of the coder's repertoire.